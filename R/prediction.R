#' Create a predictive binary result object
#'
#' The binary transformation methods require a specific data format from base
#' classifiers prediction this is used to transform the result from the base
#' methods.
#'
#' @param probability A vector with probabilities predictions or with
#'  bipartitions prediction for a binary prediction.
#' @param threshold A numeric value between 0 and 1 to create the bipartitions.
#' @return An object of type '\code{binary.prediction}' used by problem
#'  transformation methods that use binary classifiers. It has only two
#'  attributes: \code{bipartition} and \code{probability}, that respectively
#'  have the bipartition and probabilities results.
#'
#' @examples
#' probs <- runif(10, 0, 1)
#' as.binaryPrediction(probs)
#'
#' # Use different threshold value
#' probs <- runif(10, 0, 1)
#' result <- as.binaryPrediction(probs, 0.6)
as.binaryPrediction <- function(probability, threshold = 0.5) {
  bipartition <- probability
  active <- bipartition >= threshold
  bipartition[active] <- 1
  bipartition[!active] <- 0

  get_binary_prediction(bipartition, probability)
}

#' Create a predictive multi-label result
#'
#' This function select the correct result and organize them in a prediction
#'  matrix where the columns are the labels and the rows are the test examples.
#'  If probability is \code{TRUE} the values contain the labels probabilities,
#'  otherwise the values are the predictive value '0' or '1'.
#'
#' @param predictions The list of binary.prediction obtained from union of all
#'  binary predictions.
#' @param probability A logical value. If \code{TRUE} the predicted values are
#'  the score between 0 and 1, otherwise the values are bipartition 0 or 1.
#' @return A matrix containing the probabilistic values or just predictions.
#'  If the matrix contains the probabilistic values then an attribute called
#'  'classes' contains the bipartitions values. Otherwise, if the matrix
#'  contains the bipartitions values then an attribute called 'probs' cantains
#'  the probabilities
#'
#' @examples
#' ...
#' predictions <- list()
#' predictions$class1 <- mlpredict(model1, testdata)
#' predictions$class2 <- mlpredict(model2, testdata)
#' result1 <- as.multilabelPrediction(predictions, TRUE)
#' result2 <- as.multilabelPrediction(predictions, FALSE)
#'
#' all(result1 == attr(result2, 'probs')) # TRUE
#' all(result2 == attr(result1, 'classes')) # TRUE
#' ...
as.multilabelPrediction <- function(predictions, probability) {
  probabilities <- sapply(predictions, function(lblres) {
    as.numeric(as.character(lblres$probability))
  })
  bipartitions <- sapply(predictions, function(lblres) {
    as.numeric(as.character(lblres$bipartition))
  })
  rownames(probabilities) <- rownames(bipartitions) <-
    names(predictions[[1]]$bipartition)

  get_multilabel_prediction(bipartitions, probabilities, probability)
}

#' @title Create Dynamically the model for Binary Relevance Methods
#'
#' @param dataset An object generated by the \code{\link{transform_br_data}}
#'  method
#' @param ... Others arguments passed to the base method
#' @return The model dinamically generated
#'
#' @examples
#' # Create a model for each dataset in datasets list
#' lapply(datasets, create_br_model, ...)
create_br_model <- function(dataset, ...) {
  params <- c(list(dataset = dataset), ...)

  # Call dynamic multilabel model with merged parameters
  model <- do.call(mltrain, params)
  attr(model, "labelname") <- dataset$labelname
  attr(model, "methodname") <- dataset$methodname

  model
}

#' Dinamically call the prediction function
#'
#' @param model A model generated by \code{\link{create_br_model}} method
#' @param newdata The data to be predicted
#' @param ... Others arguments passed to the base method
#'
#' @return An object of type mlresult generated by the
#'  \code{\link{as.binaryPrediction}} method
#'
#' @examples
#' #Use all models to predict newdata
#' lapply(models, predict_br_model, newdata = newdata, ...)
predict_br_model <- function(model, newdata, ...) {
    label <- attr(model, "labelname")
    params <- c(list(model = model, newdata = newdata), ...)
    as.binaryPrediction(do.call(mlpredict, params)[, "1"])
}

#' Create a Binary MultiLabel Data
#'
#' @param dataset A data.frame with the data (the last column must be the class
#'  column)
#' @param classname The name of specific class of the object
#' @param base.method The name of the base method that will process this dataset
#' @param ... Extra parameters for adding in the dataset object
#' @return A list with data, labelname, labelindex and methodname.
#'    This list has three classes: mltransformation, baseMETHODNAME and
#'    a specific name
#'
#' @examples
#' ...
#' tbl <- transform_br_data(dataframe, 'mldBR', 'SVM')
#' ...
transform_br_data <- function(dataset, classname, base.method, ...) {
  label <- colnames(dataset)[length(dataset)]

  # Convert the class column as factor
  dataset[, label] <- as.factor(dataset[, label])

  # Create data
  dataset <- list(data = dataset,
                  labelname = label,
                  labelindex = ncol(dataset),
                  methodname = base.method)
  class(dataset) <- c(classname,
                      paste("base", base.method, sep = ""),
                      "mltransformation")

  extra <- list(...)
  for (nextra in names(extra)) {
    dataset[[nextra]] <- extra[[nextra]]
  }

  dataset
}

#' Create a binary.prediction object
#'
#' @param bipartition The classes predictions (bipartition values), only 0 and 1
#' @param probability The probability/confidence of a prediction, between 0..1
#' @return An object of type binary.prediction
get_binary_prediction <- function(bipartition, probability) {
  res <- list(bipartition = bipartition, probability = probability)
  class(res) <- "binary.prediction"
  res
}

#' Create an object mlresult
#'
#' @param bipartitions The matrix of predictions (bipartition values),
#'  only 0 and 1
#' @param probabilities The matrix of probability/confidence of a prediction,
#'  between 0..1
#' @param probability A logical value. If \code{TRUE} the predicted values are
#'  the score between 0 and 1, otherwise the values are bipartition 0 or 1.
#' @return An object of type mlresult
get_multilabel_prediction <- function(bipartitions,
                                      probabilities,
                                      probability) {
  # At least one label is predict
  for (row in seq(nrow(bipartitions))) {
    bipartitions[row, which.max(probabilities[row, ])] <- 1
  }

  only.bipartitions <- bipartitions
  only.probabilities <- probabilities
  attr(probabilities, "classes") <- only.bipartitions
  attr(probabilities, "type") <- "probability"

  attr(bipartitions, "probs") <- only.probabilities
  attr(bipartitions, "type") <- "bipartition"

  class(probabilities) <- class(bipartitions) <- "mlresult"

  utiml_ifelse(probability, probabilities, bipartitions)
}

#' Convert a mlresult to a matrix
#'
#' @param x The mlresult object
#' @return matrix
#' @export
as.matrix.mlresult <- function(x) {
  attr.name <- ifelse(attr(x, "type") == "bipartition", "probs", "classes")
  only.expected <- x
  attr(only.expected, attr.name) <- NULL
  attr(only.expected, "type") <- NULL
  class(only.expected) <- "matrix"
  only.expected
}

#' Convert a mlresult to a matrix with bipartition values
#'
#' @param x The mlresult object
#' @return matrix with bipartition values
#' @export
as.bipartition <- function(mlresult) {
  utiml_ifelse(is.bipartition(mlresult),
               as.matrix(mlresult),
               attr(mlresult, "classes"))
}

#' Convert a mlresult to a matrix with probabilities values
#'
#' @param x The mlresult object
#' @return matrix with probabilities values
#' @export
as.probability <- function(mlresult) {
  utiml_ifelse(is.probability(mlresult),
               as.matrix(mlresult),
               attr(mlresult, "probs"))
}

#' Test if a mlresult contains crisp values as default
#'
#' @param x The mlresult object
#' @return logical value
#' @export
is.bipartition <- function(mlresult) {
  attr(mlresult, "type") == "bipartition"
}

#' Test if a mlresult contains score values as default
#'
#' @param x The mlresult object
#' @return logical value
#' @export
is.probability <- function(mlresult) {
  attr(mlresult, "type") == "probability"
}

#' Print the mlresult
#' @export
print.mlresult <- function(x, ...) {
  print(as.matrix(x), ...)
}

#' Head mlresult as matrix
#' @export
head.mlresult <- function(x, ...) {
  head(as.matrix(x), ...)
}

#' Tail mlresult as matrix
#' @export
tail.mlresult <- function(x, ...) {
  tail(as.matrix(x), ...)
}
