#' Create a predictive binary result object
#'
#' The binary transformation methods require a specific data format from base
#' classifiers prediction this is used to transform the result from the base
#' methods.
#'
#' @param probability A vector with probabilities predictions or with
#'  bipartitions prediction for a binary prediction.
#' @param threshold A numeric value between 0 and 1 to create the bipartitions.
#' @return An object of type '\code{binary.prediction}' used by problem
#'  transformation methods that use binary classifiers. It has only two
#'  attributes: \code{bipartition} and \code{probability}, that respectively
#'  have the bipartition and probabilities results.
#'
#' @examples
#' \dontrun{
#' probs <- runif(10, 0, 1)
#' as.binaryPrediction(probs)
#'
#' ## Use different threshold value
#' probs <- runif(10, 0, 1)
#' result <- as.binaryPrediction(probs, 0.6)
#' }
as.binaryPrediction <- function(probability, threshold = 0.5) {
  bipartition <- probability
  active <- bipartition >= threshold
  bipartition[active] <- 1
  bipartition[!active] <- 0

  get_binary_prediction(bipartition, probability)
}

#' Create a predictive multi-label result
#'
#' This function select the correct result and organize them in a prediction
#'  matrix where the columns are the labels and the rows are the test examples.
#'  If probability is \code{TRUE} the values contain the labels probabilities,
#'  otherwise the values are the predictive value '0' or '1'.
#'
#' @param predictions The list of binary.prediction obtained from union of all
#'  binary predictions.
#' @param probability A logical value. If \code{TRUE} the predicted values are
#'  the score between 0 and 1, otherwise the values are bipartition 0 or 1.
#' @return A matrix containing the probabilistic values or just predictions.
#'  If the matrix contains the probabilistic values then an attribute called
#'  'classes' contains the bipartitions values. Otherwise, if the matrix
#'  contains the bipartitions values then an attribute called 'probs' cantains
#'  the probabilities
#'
#' @examples
#' \dontrun{
#' predictions <- list()
#' predictions$class1 <- mlpredict(model1, testdata)
#' predictions$class2 <- mlpredict(model2, testdata)
#' result1 <- as.multilabelPrediction(predictions, TRUE)
#' result2 <- as.multilabelPrediction(predictions, FALSE)
#'
#' all(result1 == attr(result2, 'probs')) # TRUE
#' all(result2 == attr(result1, 'classes')) # TRUE
#' }
as.multilabelPrediction <- function(predictions, probability) {
  probabilities <- do.call(cbind, lapply(predictions, function(lblres) {
    as.numeric(as.character(lblres$probability))
  }))
  bipartitions <- do.call(cbind, lapply(predictions, function(lblres) {
    as.numeric(as.character(lblres$bipartition))
  }))
  rownames(probabilities) <- rownames(bipartitions) <-
    names(predictions[[1]]$bipartition)

  get_multilabel_prediction(bipartitions, probabilities, probability)
}

#' Create a data.frame from original mldr data for a single label
#'
#' @param mdata The mldr dataset
#' @param label.name The name of the label
#' @param extra.columns New columns to be added in the new dataset
#' @return a data.frame where the label is the last column
create_br_data <- function (mdata, label.name, extra.columns = NULL) {
  if (is.null(extra.columns)) {
    cbind(mdata$dataset[mdata$attributesIndexes], mdata$dataset[label.name])
  }
  else {
    cbind(mdata$dataset[mdata$attributesIndexes],
          extra.columns,
          mdata$dataset[label.name])
  }
}

#' Create Dynamically the model for Binary Relevance Methods
#'
#' This method is used in the methods to call dinamicaly the base classifier
#'
#' @param dataset An object generated by the \code{\link{prepare_br_data}}
#'  method
#' @param ... Others arguments passed to the base method
#' @return The model dinamically generated
create_br_model <- function(dataset, ...) {
  params <- c(list(dataset = dataset), ...)

  # Call dynamic multilabel model with merged parameters
  model <- do.call(mltrain, params)
  attr(model, "labelname") <- dataset$labelname
  attr(model, "methodname") <- dataset$methodname

  model
}

#' Dinamically call the prediction function
#'
#' @param model A model generated by \code{\link{create_br_model}} method
#' @param newdata The data to be predicted
#' @param ... Others arguments passed to the base method
#'
#' @return An object of type mlresult generated by the
#'  \code{\link{as.binaryPrediction}} method
#'
#' @examples
#' \dontrun{
#' ## Use all models to predict newdata
#' lapply(models, predict_br_model, newdata = newdata)
#' }
predict_br_model <- function(model, newdata, ...) {
  label <- attr(model, "labelname")
  params <- c(list(model = model, newdata = newdata), ...)
  result <- utiml_renames(do.call(mlpredict, params)[, "1"], rownames(newdata))
  as.binaryPrediction(result)
}

#' Prepare a Binary MultiLabel Data to be processed
#'
#' @param dataset A data.frame with the data (the last column must be the class
#'  column)
#' @param classname The name of specific class of the object
#' @param base.method The name of the base method that will process this dataset
#' @param ... Extra parameters for adding in the dataset object
#' @return A list with data, labelname, labelindex and methodname.
#'    This list has three classes: mltransformation, baseMETHODNAME and
#'    a specific name
#'
#' @examples
#' \dontrun{
#' tbl <- prepare_br_data(dataframe, 'mldBR', 'SVM')
#' }
prepare_br_data <- function(dataset, classname, base.method, ...) {
  label <- colnames(dataset)[length(dataset)]

  # Convert the class column as factor
  dataset[, label] <- as.factor(dataset[, label])

  # Create data
  dataset <- list(data = dataset,
                  labelname = label,
                  labelindex = ncol(dataset),
                  methodname = base.method)
  class(dataset) <- c(classname,
                      paste("base", base.method, sep = ""),
                      "mltransformation")

  extra <- list(...)
  for (nextra in names(extra)) {
    dataset[[nextra]] <- extra[[nextra]]
  }

  dataset
}

#' Create a binary.prediction object
#'
#' @param bipartition The classes predictions (bipartition values), only 0 and 1
#' @param probability The probability/confidence of a prediction, between 0..1
#' @return An object of type binary.prediction
get_binary_prediction <- function(bipartition, probability) {
  res <- list(bipartition = bipartition, probability = probability)
  class(res) <- "binary.prediction"
  res
}

#' Create an object mlresult
#'
#' @param bipartitions The matrix of predictions (bipartition values),
#'  only 0 and 1
#' @param probabilities The matrix of probability/confidence of a prediction,
#'  between 0..1
#' @param probability A logical value. If \code{TRUE} the predicted values are
#'  the score between 0 and 1, otherwise the values are bipartition 0 or 1.
#' @return An object of type mlresult
get_multilabel_prediction <- function(bipartitions,
                                      probabilities,
                                      probability) {
  # At least one label is predict
  for (row in seq(nrow(bipartitions))) {
    bipartitions[row, which.max(probabilities[row, ])] <- 1
  }

  bipartitions <- as.matrix(bipartitions)
  probabilities <- as.matrix(probabilities)

  only.bipartitions <- bipartitions
  only.probabilities <- probabilities
  attr(probabilities, "classes") <- only.bipartitions
  attr(probabilities, "type") <- "probability"

  attr(bipartitions, "probs") <- only.probabilities
  attr(bipartitions, "type") <- "bipartition"

  class(probabilities) <- class(bipartitions) <- "mlresult"

  utiml_ifelse(probability, probabilities, bipartitions)
}

#' Filter a Multi-Label Result
#' @param mlresult A mlresult object
#' @param rowFilter A list of rows to filter
#' @param colFilter A list of columns to filter
#' @param ... Extra parameters to be used as the filter
#' @export
`[.mlresult` <- function (mlresult, rowFilter = T, colFilter, ...) {
  if (missing(colFilter)) {
    bipartition <- as.bipartition(mlresult)
    probability <- as.probability(mlresult)

    get_multilabel_prediction(bipartition[rowFilter, ],
                              probability[rowFilter, ],
                              is.probability(mlresult))
  } else {
    as.matrix(mlresult)[rowFilter, colFilter, ...]
  }
}

#' Convert a matrix prediction in a multi label prediction
#' @param predictions a Matrix or data.frame contained the scores/probabilities
#' values
#' @param probability A logical value. If \code{TRUE} the predicted values are
#'  the score between 0 and 1, otherwise the values are bipartition 0 or 1.
#' @param ... Others parameters passed to the method as threshold
#' @return An object of type mlresult
#' @export
#'
#' @examples
#' predictions <- matrix(sample(1:1000, 100, replace = TRUE) / 1000, ncol = 10)
#' colnames(predictions) <- paste('label', 1:10, sep='')
#'
#' as.mlresult(predictions)
#' as.mlresult(predictions, probability = FALSE)
#' as.mlresult(predictions, threshold = 0.6)
as.mlresult <- function(predictions, ...) {
  UseMethod("as.mlresult")
}

#' @describeIn as.mlresult Default mlresult transform method
#' @export
as.mlresult.default <- function (predictions, probability = T, threshold = 0.5,
                                 ...) {
  as.mlresult.matrix(as.matrix(predictions), probability)
}

#' @describeIn as.mlresult Matrix mlresult transform method
#' @param threshold Threshold value for create bipartition (Default: 0.5)
#' @export
as.mlresult.matrix <- function (predictions, probability = T, threshold = 0.5,
                                ...) {
  bipartition <- fixed_threshold(predictions, threshold)
  get_multilabel_prediction(bipartition, predictions, probability)
}

#' @describeIn as.mlresult change the mlresult type
#' @export
as.mlresult.mlresult <- function (predictions, probability = T, ...) {
  bipartition <- as.bipartition(predictions)
  probabilities <- as.probability(predictions)
  get_multilabel_prediction(bipartition, probabilities, probability)
}

#' Convert a mlresult to a matrix
#'
#' @param x The mlresult object
#' @param ... ignored
#' @return matrix
#' @export
as.matrix.mlresult <- function(x, ...) {
  attr.name <- ifelse(attr(x, "type") == "bipartition", "probs", "classes")
  only.expected <- x
  attr(only.expected, attr.name) <- NULL
  attr(only.expected, "type") <- NULL
  class(only.expected) <- "matrix"
  only.expected
}

#' Convert a mlresult to a matrix with bipartition values
#'
#' @param mlresult The mlresult object
#' @return matrix with bipartition values
#' @export
as.bipartition <- function(mlresult) {
  utiml_ifelse(is.bipartition(mlresult),
               as.matrix(mlresult),
               attr(mlresult, "classes"))
}

#' Convert a mlresult to a matrix with probabilities values
#'
#' @param mlresult The mlresult object
#' @return matrix with probabilities values
#' @export
as.probability <- function(mlresult) {
  utiml_ifelse(is.probability(mlresult),
               as.matrix(mlresult),
               attr(mlresult, "probs"))
}

#' Test if a mlresult contains crisp values as default
#'
#' @param mlresult The mlresult object
#' @return logical value
#' @export
is.bipartition <- function(mlresult) {
  attr(mlresult, "type") == "bipartition"
}

#' Test if a mlresult contains score values as default
#'
#' @param mlresult The mlresult object
#' @return logical value
#' @export
is.probability <- function(mlresult) {
  attr(mlresult, "type") == "probability"
}

#' Print the mlresult
#' @param x The mlresult to print
#' @param ... Extra parameters for print method
#' @export
print.mlresult <- function(x, ...) {
  print(as.matrix(x), ...)
}

# #' Head mlresult as matrix
# #' @export
# head.mlresult <- function(x, n = 6L, ...) {
#   head(as.matrix(x), n, ...)
# }
#
# #' Tail mlresult as matrix
# #' @export
# tail.mlresult <- function(x, n = 6L, ...) {
#   tail(as.matrix(x), n, ...)
# }
