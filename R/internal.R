#
# This file contains internal functions related with multi-label concepts
# All these function are not available public in the package
# The functions are sorted in alphabetical order
#

#' @title Create a predictive multi-label result
#' @description This function select the correct result and organize them in a
#'  prediction matrix where the columns are the labels and the rows are the
#'  test examples. If probability is \code{TRUE} the values contain the labels
#'  probabilities, otherwise the values are the predictive value "0" or "1".
#'
#' @param predictions The list of mlresult obtained from union of all binary
#'  predictions.
#' @param probability A logical value. If \code{TRUE} the predicted values are
#'  the score between 0 and 1, otherwise the values are bipartition 0 or 1.
#'
#' @return A matrix containing the probabilistic values or just predictions.
#'  If the matrix contains the probabilistic values then an attribute called
#'  "classes" contains the bipartitions values. Otherwise, if the matrix
#'  contains the bipartitions values then an attribute called "probs" cantains
#'  the probabilities
#' @export
#'
#' @examples
#' ...
#' predictions <- list()
#' predictions$class1 <- mlpredict(model1, testdata)
#' predictions$class2 <- mlpredict(model2, testdata)
#' result1 <- as.resultMLPrediction(predictions, TRUE)
#' result2 <- as.resultMLPrediction(predictions, FALSE)
#'
#' all(result1 == attr(result2, "probs")) # TRUE
#' all(result2 == attr(result1, "classes")) # TRUE
#' ...
as.resultMLPrediction <- function (predictions, probability) {
  probabilities <- sapply(predictions, function (lblres) as.numeric(as.character(lblres$probability)))
  bipartitions <- sapply(predictions, function (lblres) as.numeric(as.character(lblres$bipartition)))
  rownames(probabilities) <- rownames(bipartitions) <- names(predictions[[1]]$bipartition)

  only.probabilities <- probabilities
  attr(probabilities, "classes") <- bipartitions
  attr(bipartitions, "probs") <- only.probabilities

  utiml_ifelse(probability, probabilities, bipartitions)
}

#' @title Create Dynamically the model for Binary Relevance Methods
#'
#' @param dataset An object generated by the \code{\link{br.transformation}} method
#' @param ... Others arguments passed to the base method
#'
#' @return The model dinamically generated
#' @export
#'
#' @examples
#' # Create a model for each dataset in datasets list
#' lapply(datasets, br.create_model, ...)
br.create_model <- function (dataset, ...) {
  params <- c(list(dataset=dataset), ...)

  #Call dynamic multilabel model with merged parameters
  model <- do.call(mltrain, params)
  attr(model, "labelname") <- dataset$labelname
  attr(model, "methodname") <- dataset$methodname

  model
}

#' @title Dinamically call the prediction function
#'
#' @param model A model generated by \code{\link{br.create_model}} method
#' @param newdata The data to be predicted
#' @param ... Others arguments passed to the base method
#'
#' @return An object of type mlresult generated by the
#'  \code{\link{as.binaryPrediction}} method
#' @export
#'
#' @examples
#' #Use all models to predict newdata
#' lapply(models, br.predict_model, newdata = newdata, ...)
br.predict_model <- function (model, newdata, ...) {
  label <- attr(model, "labelname")
  params <- c(list(model = model, newdata = newdata), ...)
  do.call(mlpredict, params)
}

#' Create a Binary MultiLabel Data
#'
#' @param dataset A data.frame with the data (the last column must be the class column)
#' @param classname The name of specific class of the object
#' @param base.method The name of the base method that will process this dataset
#' @param ... Extra parameters for adding in the dataset object
#'
#' @return A list with data, labelname, labelindex and methodname.
#'    This list has three classes: mltransformation, baseMETHODNAME and a specific name
#' @export
#'
#' @examples
#' ...
#' tbl <- br.transformation(dataframe, "mldBR", "SVM")
#' ...
br.transformation <- function (dataset, classname, base.method, ...) {
  label <- colnames(dataset)[length(dataset)]

  #Convert the class column as factor
  dataset[,label] <- as.factor(dataset[,label])

  #Create data
  dataset <- list(data = dataset, labelname = label, labelindex = ncol(dataset), methodname = base.method)
  class(dataset) <- c(classname, paste("base", base.method, sep=''), "mltransformation")

  extra <- list(...)
  for (nextra in names(extra))
    dataset[[nextra]] <- extra[[nextra]]

  dataset
}

#' @title Return the newdata to a data.frame or matrix
#'
#' @param newdata The data.frame or mldr data
#'
#' @return A dataframe or matrix containing only dataset
#' @export
#'
#' @examples
#' test <- emotions$dataset[,emotions$attributesIndexes]
#' all(test == utiml_newdata(emotions)) # TRUE
#' all(test == utiml_newdata(test)) # TRUE
utiml_newdata <- function (newdata) UseMethod("utiml_newdata")

#' @describeIn utiml_newdata
utiml_newdata.default <- function (newdata) newdata

#' @describeIn utiml_newdata
utiml_newdata.mldr <- function (newdata) newdata$dataset[,newdata$attributesIndexes]
